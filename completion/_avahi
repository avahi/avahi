#compdef avahi-browse avahi-browse-domains avahi-publish avahi-publish-address avahi-publish-service avahi-resolve avahi-resolve-address avahi-resolve-host-name avahi-set-host-name

# Completion function for zsh

local curcontext="$curcontext" pri aarg sarg ret=1
local -A opt_args
local -a state line args serv desc disp

args=(
  '(- 1)'{-h,--help}'[display usage information]'
  '(- 1)'{-V,--version}'[display version information]'
  '(-v --verbose)'{-v,--verbose}'[enable verbose mode]'
)

case $service in
  *-browse*)
    serv=( ${(f)"$(_call_program service-types avahi-browse -bk)"} )
    desc=( ${(f)"$(_call_program service-types-description avahi-browse -b)"} )
    (( $#desc )) && print -v disp -f '%s:%s' ${serv:^desc}

    _arguments -s -S -C $args \
      '(-D --browse-domains -a --all -b --dump-db)'{-D,--browse-domains}'[browse for browsing domains instead of services]' \
      '(-D --browse-domains -a --all -b --dump-db)'{-a,--all}'[show all services, regardless of the type]' \
      '(-d --domain)'{-d+,--domain=}'[specify domain to browse in]:domain' \
      '(-t --terminate)'{-t,--terminate}'[terminate after dumping a more or less complete list]' \
      '(-c --cache)'{-c,--cache}'[terminate after dumping all entries from the cache]' \
      '(-l --ignore-local)'{-l,--ignore-local}'[ignore local services]' \
      '(-r --resolve)'{-r,--resolve}'[resolve services found]' \
      '(-f --no-fail)'{-f,--no-fail}"[don't fail if the daemon is not available]" \
      '(-p --parsable)'{-p,--parsable}'[output in parsable format]' \
      '(-k --no-db-lookup)'{-k,--no-db-lookup}"[don't lookup service types]" \
      '(-D --browse-domains -a --all -b --dump-db)'{-b,--dump-db}'[dump service type database]' \
      '1: :->service-types' && ret=0

    [[ -n $state ]] && _describe -t services "service type" disp && ret=0
  ;;
  *-publish*)
    aarg=${(M)words[1,CURRENT-1]:#-(a|-address)}
    sarg=${(M)words[1,CURRENT-1]:#-(s|-service)}
    if [[ -n $aarg || ( -z $sarg && $service = *-address ) ]]; then
      args+=(
        '1: : _guard "^-*" "hostname"'
        '2:address'
      )
    elif [[ -n $sarg || $service = *-service ]]; then
      args+=(
        '1: : _guard "^-*" "name"'
        '2:service type'
        '3:port:_ports'
        '*:TXT data'
      )
    fi

    _arguments -s -S $args \
      '(-d --domain)'{-d+,--domain=}'[domain to publish service in]:domain' \
      '(-H --host)'{-H+,--host=}'[specify host where service resides]:host:_hosts' \
      '--subtype=[specify additional subtype to register this service with]:subtype' \
      '(-R --no-reverse)'{-R,--no-reverse}'[do not publish reverse entry with address]' \
      '(-f --no-fail)'{-f,--no-fail}"[don't fail if the daemon is not available]" \
      + '(action)' \
      {-s,--service}'[publish service]' \
      {-a,--address}'[publish address]' && ret=0
  ;;
  *-resolve*)
    if (( ${words[(I)(-n|--name)]} )) || [[ $service = *-host-name ]]; then
       args=( '*:host:_hosts' )
       pri=1
    fi
    if (( ${words[(I)(-a|--address)]} )) || [[ $service = *-address && -n $pri ]]; then
       args=( '*: :_guard "^-*" address' )
    fi

    _arguments -s -S $args \
      '(-a --address -n --name -h --help -V --version)'{-a,--address}'[resolve address]' \
      '(-a --address -n --name -h --help -V --version)'{-n,--name}'[resolve host name]' \
      '(-4)-6[lookup IPv6 address]' \
      '(-6)-4[lookup IPv4 address]' && ret=0
  ;;
  *-set-host-name)
    _arguments -s -S $args '1: : _guard "^-*" "hostname"' && ret=0
  ;;
esac

return ret
